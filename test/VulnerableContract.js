// test/VulnerableContractTest.js
const { expect } = require("chai")
const hre = require("hardhat")

describe("VulnerableContract", () => {
  it("should allow the attacker to exploit the re-entrancy vulnerability", async () => {
    const vulnerableContract = await hre.ethers.deployContract("VulnerableContract", [])
    await vulnerableContract.waitForDeployment()

    const attackContract = await hre.ethers.deployContract("AttackContract", [
      vulnerableContract.target
    ])
    await attackContract.waitForDeployment()

    const [_, user, attacker] = await hre.ethers.getSigners()

    // A user deposits funds to the vulnerable contract
    const userDeposit = hre.ethers.parseEther("5")
    const depositTx = await vulnerableContract.connect(user).deposit({ value: userDeposit })
    await depositTx.wait()

    // Check that at this point the GoodContract's balance is 10 ETH
    let vulnerableContractBalance = await hre.ethers.provider.getBalance(
      vulnerableContract.target
    )
    expect(vulnerableContractBalance).to.equal(userDeposit)

    // Attacker launches the attack
    const attackTx = await attackContract.connect(attacker).attack({
      value: hre.ethers.parseEther("0.1"),
    })
    await attackTx.wait()

    // Check the attacker's balance
    const attackerBalance = await hre.ethers.provider.getBalance(attackContract.target)
    expect(attackerBalance).to.be.above(hre.ethers.parseEther("5"))

    // Check the vulnerable contract's balance (should be drained)
    const vulnerableBalance = await hre.ethers.provider.getBalance(vulnerableContract.target)
    expect(vulnerableBalance).to.equal(0)
  })
})
